# -*- coding: utf-8 -*-

"""
Module implementing MainWindow.
"""

from PyQt4 import QtCore, QtGui
from PyQt4.QtGui import QMainWindow
from PyQt4.QtCore import pyqtSignature
from PyQt4.QtCore import QTimer,  SIGNAL, SLOT, Qt,  QRect
from PyQt4.QtGui import QPainter, QRegion, QPen
import sys, random
from struct import unpack
from Utilities import *

PIXEL_OFFSET = 200 # pixels offset

from Ui_Display import Ui_Dialog

class Channel:
    def __init__(self, dialog, name, id, width = 2, color = 'Qt.blue'):
        exec interp('self.id = #{id}')
        exec interp('self.width = #{width}')
        exec interp('self.color = #{color}')
        exec interp('self.vscale = 0.0')
        exec interp('self.yoffset = 1.0')
        exec interp('self.slider = QtGui.QSlider(dialog)')
        exec interp('self.slider.setGeometry(QtCore.QRect(100, 130+#{id}*100, 29, 100))')
        exec interp('self.slider.setOrientation(QtCore.Qt.Vertical)')
        exec interp('self.slider.setObjectName("gain_#{name}")')

class View(QMainWindow, Ui_Dialog):
    """
    Class View inherits the GUI generated by QtDesigner, and add customized actions
    """
    def __init__(self, parent = None, VIEWER_REFRESH_RATE = 5, ch_all = []):
        """
        Constructor
        """
#        QMainWindow.__init__(self, parent, Qt.FramelessWindowHint)
        QMainWindow.__init__(self, parent)
        self.setupUi(self)
        self.x = 200
        self.data = self.data_1 = ZERO_DATA
        self.pen = QPen()

        self.numPt = PIXEL_OFFSET
        self.isPause = False
        self.NUM_CHANNEL = len(CHIN_PARAM)

        # Create a gain_slider for each channel
        self.ch_all = []
        for (addr, name, visual_gain, type, color), i in zip(CHIN_PARAM, xrange(NUM_CHANNEL)):
            print color, 
            exec interp('self.ch_#{name} = Channel(dialog=self, name=name, id=i, color = color)')
            exec interp('self.connect(self.ch_#{name}.slider, SIGNAL("valueChanged(int)"), self.onChInGain)')
            exec interp('self.ch_all.append(self.ch_#{name})')

        #print self.ch_all
        self.timer = QTimer(self)
        self.connect(self.timer, SIGNAL("timeout()"), self.onTimeOut)        
        self.timer.start(VIEWER_REFRESH_RATE)

    def newData(self, newData, newSpike = ''):
        self.data_1 = self.data
        self.data = newData
        self.spike = newSpike

    def onTimeOut(self):
        if (self.isPause):
            return
        size = self.size()
        self.update(QRect(self.x, 0,size.width() - self.x + 3,size.height()))

        if (self.x < size.width()):
            self.x = self.x + 1     
        else:
            self.x = PIXEL_OFFSET
            
    def onChInGain(self):
        for ch in self.ch_all:
            ch.vscale = ch.slider.value()* 0.01           

    def paintEvent(self, e):
        """ 
        Overload the standard paintEvent function
        """

        #p = QPainter(self.graphicsView)                         ## our painter
        canvas = QPainter(self)                         ## our painter
        self.drawPoints(canvas, self.ch_all)          ## paint clipped graphics
        self.drawRaster(canvas)

    def drawRaster(self, gp):
        spikeSeq = unpack("%d" % len(self.spike) + "b", self.spike)
        
        size = self.size()
        winScale = size.height()*0.2 + size.height()*0.618/self.NUM_CHANNEL * 4;
        self.pen.setStyle(Qt.SolidLine)
        self.pen.setWidth(4)
        self.pen.setBrush(Qt.blue)
        self.pen.setCapStyle(Qt.RoundCap)
        self.pen.setJoinStyle(Qt.RoundJoin)
        gp.setPen(self.pen)
        ## display the spike rasters
        for i in xrange(0, len(spikeSeq), 2):
            neuronID = spikeSeq[i+1]
            rawspikes = spikeSeq[i]
            ## flexors
            if (rawspikes & 64) : ## Ia
                gp.drawLine(self.x-2,(winScale) - 22 ,\
                                 self.x, (winScale) -  22)
            if (rawspikes & 128) : ## MN
#                gp.drawPoint(self.x, (winScale) - 24 - (neuronID/4)   ) 
                gp.drawLine(self.x-3,(winScale) - 25 - (neuronID/4) ,\
                                 self.x+3, (winScale) - 22 - (neuronID/4) )

    def drawPoints(self, qp, ch_all):
        """ 
        Draw a line between previous and current data points.
        """
        size = self.size()

        for ch in ch_all:
            self.pen.setStyle(Qt.SolidLine)
            self.pen.setWidth(2)
            self.pen.setBrush(ch.color)
            self.pen.setCapStyle(Qt.RoundCap)
            self.pen.setJoinStyle(Qt.RoundJoin)
            qp.setPen(self.pen)

            yOffset = int(size.height()*0.2 + size.height()*0.618/self.NUM_CHANNEL * ch.id)
            qp.drawLine(self.x - 2, yOffset - self.data_1[ix] * ch.vscale,\
                        self.x , yOffset - self.data[ix] * ch.vscale)
  

    @pyqtSignature("bool")
    def on_pushButton_toggled(self, checked):
        """
        Pausing the plot, FPGA calculation still continues.
        """
        self.isPause = checked

    @pyqtSignature("bool")
    def on_checkBox_clicked(self, checked):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        raise NotImplementedError
